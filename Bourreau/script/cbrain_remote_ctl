#!/usr/bin/env ruby

#
# CBRAIN Project
#
# Copyright (C) 2008-2021
# The Royal Institution for the Advancement of Learning
# McGill University
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#



# This script is a wrapper that launches the normal Rails server,
# but with the added ability of receiving the content of the database.yml
# file in standard output before it does so. Also, once the server is
# started, the database.yml is deleted outright, closing a security hole.
#
# This script it NOT usually executed by a human, instead it is
# invoked by the Portal when trying to start or stop a Bourreau.
#
# The command-line args are to be provided strictly in the order shown
# below, and all of them should be present (this is done simply so that
# this bash script is kept simple, as anyway this script is not meant
# to be started manually by users).
#
#
# To start the Rails app:
#
#   $0 start -e <environment>
#
# which will result in reading the database.yml from stdin, installing
# it, executing this command
#
#   puma --config config/puma.rb
#
# and finally removing the database.yml file. Any database.yml file
# already present before doing all this will be erased.
#
#
# To stop the Rails app:
#
#   $0 stop
#
# which will result in killing the rails app.
#
#
# To start a console
#
#   $0 console -e <environment>



#require 'rubygems'
#require 'active_support'
#require 'active_support/core_ext.rb'
#require 'etc'
#require File.dirname(__FILE__) + '/../lib/cbrain_file_revision.rb' # ugly
#require File.dirname(__FILE__) + '/../lib/cbrain_extensions/string_extensions/utilities.rb' # SO UGLEEEEE!!!!
#require File.dirname(__FILE__) + '/../config/initializers/added_core_extensions/string.rb' # ugly


#########################
# S U B R O U T I N E S #
#########################

# Usage
def usage(basename)
    puts "Usage: #{basename} start -e <environment>\n" +
         "       #{basename} stop\n" +
         "       #{basename} console -e <environment>"
    Kernel.exit(10)
end

# Fatal error message
def fatal(message)
    puts message
    Kernel.exit(20)
end

# Run-time paths
cwd      = Dir.getwd
basename = $PROGRAM_NAME
fullprog = basename =~ /^\// ? basename : cwd + "/" + basename

# Rails-specific paths
rails_home = fullprog.sub(/\/script\/.+$/,"")
pidfile    = "#{rails_home}/tmp/pids/server.pid"

# To help diagnose problems, print Ruby's version.
puts "You are using Ruby #{RUBY_VERSION}"
if RUBY_VERSION =~ /^1\.[0-8]/
  puts "Warning! This Ruby version seems to be way too old. Maybe your environment wasn't initialized properly?"
end

# Check usage
usage(basename) if ARGV.size != 1 && ARGV.size != 3 && ARGV.size != 5    # 1, 3 or 5 args!

#############################################################
# STOP
#############################################################

if ARGV.size == 1
    usage(basename) if ARGV[0] != "stop"
    fp = File.open(pidfile,"r") rescue nil
    if fp
        pid = fp.read.to_i
        fp.close
        Process.kill("TERM", pid)
        puts "Bourreau Stopped"
        Kernel.exit(0)
    end
    fatal "Could not find/open PID file '#{pidfile}'."
end

#############################################################
# ARGUMENT CHECKS FOR OTHER MODES (start or console)
#############################################################

if ARGV[0] == "start"      # start -e env
  usage(basename) if ARGV.size != 3 || ARGV[1] != "-e"
elsif ARGV[0] == "console" # console -e env
  usage(basename) if ARGV.size != 3 || ARGV[1] != "-e"
else
  usage(basename)
end
mode = ARGV[0] # 'start' or 'console'

if mode == "start" && File.exist?(pidfile)
  pid = File.read(pidfile).to_i
  # The command below echoes back the PID if the process exists,
  # and happens to work on both Linux and MacOS.
  exists = `ps -p #{pid} -o pid=`
  if exists.match /\d+/
    fatal("The Rails app seems to be running already (PID=#{pid}). Kill it first.")
  end
  File.unlink(pidfile) rescue true
end

# Check arguments
environment = ARGV[2]
fatal("Environment argument must be 'production', 'development' or 'test'") unless
   environment =~ /^(production|development|test)$/

db_yml_text = mode == "start" ? (STDIN.read || "") : ""
db_file     = rails_home + "/config/database.yml"

# Install or restore database.yml if necessary
blank_yml  = db_yml_text !~ /\S/

if blank_yml #  blank? use what db.yml is already here
  if ! File.exist?(db_file)
    fatal("Could not find a database.yml file for the Rails application!")
  end
else # db text is provided to us
  # Substitute most recently created DB socket filename
  sockfiles = Dir.glob("#{rails_home}/tmp/sockets/db.*.sock").map { |f| Pathname.new(f) }
  fatal("Could not find a DB socket in tmp/sockets/db.*.sock") if sockfiles.size == 0
  sockfiles.sort! { |sock_a,sock_b| sock_a.mtime <=> sock_b.mtime } # order by time
  db_sockfile = sockfiles.pop.to_s # remove the last, which is the most recent
  db_yml_text.sub!(/socket:.*/,"socket: #{db_sockfile}")
  File.open(db_file,"w") { |fh| fh.write(db_yml_text) }
  sockfiles.each { |f| File.unlink(f) rescue nil } # remove all older socket files
end

###########################################
# CONSOLE START
###########################################
if mode == 'console'
  Dir.chdir(rails_home) do
    # Bash command for launching the interactive console
    start_success = system("script/rails", "console", environment) # this will BLOCK
    File.unlink(db_file) rescue true
    puts "\nBourreau Console Exited."
    Kernel.exit(start_success ? 0 : 10) # all done
  end
end

###########################################
# BOURREAU START
###########################################

# Rename log files when they are too big
date_extension       = Time.now.strftime("%Y-%m-%d")
start_log_file       = "#{rails_home}/log/server_start.log"
environment_log_file = "#{rails_home}/log/#{environment}.log"
if File.exists?( start_log_file ) && File.size( start_log_file ) > 1_048_576
  File.rename(start_log_file, start_log_file.sub(/\.log$/,"_#{date_extension}.log"))
end
if File.exists?( environment_log_file ) && File.size( environment_log_file ) > 1_048_576
  File.rename(environment_log_file, environment_log_file.sub(/\.log$/,"_#{date_extension}.log"))
end

# Start the server
start_success=false
Dir.chdir(rails_home) do
  # We provide a dummy value for the session cookie encoder.
  # TODO just documet in YAML file?
  ENV["SECRET_KEY_BASE"] ||= "JUNK-NOT-USED-IN-BOURREAU-THERE-ARE-NO-SESSIONS-ANYWAY"
  # puma_wait_wrapper is a custom program that boots puma and waits to make sure
  start_success = system("script/puma_wait_wrapper")
end

# If we were provided with a database.yml, we need
# delete it once the server has read it.
if (! blank_yml)
  File.unlink(db_file) rescue true
end

# Return a message to indicate to our calling context
# whether or not the server started.
if start_success
  puts "Bourreau Started." # This string is used by the Portal controller!
  Kernel.exit(0)
end

puts "Bourreau Failed."
puts "Raw BASH command: #{raw_system_cmd}"
#if File.exists?(start_log_file)
#  puts "Here are the last 100 lines of the server's log:"
#  system("tail -100 '#{start_log_file}'")
#else
#  puts "No server log file found to help you out of this one :-("
#end
Kernel.exit(10)

